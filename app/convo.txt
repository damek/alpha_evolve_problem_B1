Below is a react app that I was developing with an AI tool. I want to finish it. There are a few problems.
Here was my initial prompt:
"Hi want to make a minimal app that takes a step function like the top plot on the interval [-1/4, 1/4], and then allows the user to select any piece of the step function, the number of pieces, and then adjust the height with a slider. Then it plots the autoconvolution function like shown below. It should run in the in the attached plot."
Here is my feedback on the draft below:
Better! But still buggy.  1. when I click anywhere on the plot, it's unclear which column has been selected. Frequently it's not one where I'm clicking!! 2. When I click anywhere, the whole plot disappears and then sort of fills back up. I would like the it to look mostly static except for (1) displaying which column has been selected (by highlighting) and (2) showing the moving column. 3. Instead of making the step function plot normalized, plot (f\ast f)(t)/\int (f\ast f). This way we can stop constantly renormalizing the step function plot. You should change the plot labels for the autoconvolution and remove the 'total sum of heights' line.  4. I should be able to click anywhere above or on the step function box to select the step function I want to modify.
Please fix the app. Tell me how to run it. I will deploy it on my website which is a jekyll site hosted on github.
---- Draft of app ----
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ReferenceLine, ResponsiveContainer, BarChart, Bar } from 'recharts';
const StepFunctionVisualizer = () => {
// Constants
const MIN_X = -0.25;
const MAX_X = 0.25;
const DEFAULT_NUM_PIECES = 50;
const MAX_PIECES = 200;
const GOOGLE_BOUND = 1.5053;
const MAX_HEIGHT = 20;
// State variables
const [numPieces, setNumPieces] = useState(DEFAULT_NUM_PIECES);
const [stepFunction, setStepFunction] = useState([]);
const [autoconvolution, setAutoconvolution] = useState([]);
const [selectedPiece, setSelectedPiece] = useState(null);
const [currentHeight, setCurrentHeight] = useState(0);
const [totalHeight, setTotalHeight] = useState(0);
const [maxAutoconvValue, setMaxAutoconvValue] = useState(0);
const [isDragging, setIsDragging] = useState(false);
// Refs
const barChartRef = useRef(null);
// Initialize step function on component mount or when number of pieces changes
useEffect(() => {
generateRandomStepFunction();
}, [numPieces]);
// Update max autoconvolution value when autoconvolution changes
useEffect(() => {
if (autoconvolution.length > 0) {
const maxVal = Math.max(...autoconvolution.map(point => point.y));
setMaxAutoconvValue(maxVal);
}
}, [autoconvolution]);
// Normalize heights to ensure sum is 100
const normalizeHeights = useCallback((steps) => {
const sum = steps.reduce((acc, step) => acc + step.y, 0);
if (sum === 0) return steps; // Avoid division by zero

return steps.map(step => ({
  ...step,
  y: (step.y / sum) * 100
}));
Use code with caution.
}, []);
// Generate random step function
const generateRandomStepFunction = useCallback(() => {
const pieceWidth = (MAX_X - MIN_X) / numPieces;
let newStepFunction = [];
for (let i = 0; i < numPieces; i++) {
  const x = MIN_X + (i + 0.5) * pieceWidth;
  const height = Math.random() * MAX_HEIGHT;
  
  newStepFunction.push({
    x,
    y: height,
    pieceIndex: i,
    width: pieceWidth
  });
}

// Normalize to ensure sum is 100
newStepFunction = normalizeHeights(newStepFunction);

setStepFunction(newStepFunction);
setSelectedPiece(null);
setCurrentHeight(0);

calculateAutoconvolution(newStepFunction);
updateTotalHeight(newStepFunction);
Use code with caution.
}, [numPieces, normalizeHeights]);
// Update total height
const updateTotalHeight = useCallback((steps) => {
const sum = steps.reduce((acc, step) => acc + step.y, 0);
setTotalHeight(sum);
}, []);
// Calculate autoconvolution
const calculateAutoconvolution = useCallback((steps) => {
const P = numPieces;
const heights = steps.map(step => step.y);
const result = [];
// Calculate over a wider range for visualization
for (let m = 0; m <= 2 * P; m++) {
  const t = -0.5 + m / (2 * P);
  let value = 0;
  
  // Skip computation for boundary points
  if (m === 0 || m === 2 * P) {
    value = 0;
  } else {
    const kMin = Math.max(0, m - P);
    const kMax = Math.min(P - 1, m - 1);
    
    for (let k = kMin; k <= kMax; k++) {
      value += heights[k] * heights[m - 1 - k];
    }
    
    value = value / 10000; // Normalize since heights sum to 100
  }
  
  result.push({
    x: t,
    y: value
  });
}

setAutoconvolution(result);
Use code with caution.
}, [numPieces]);
// Handle piece selection
const handlePieceClick = useCallback((index) => {
if (isDragging) return;
// Find the piece at the given index
const piece = stepFunction[index];

// Update the height slider to match the selected piece's height
setCurrentHeight(piece.y);

// Set the selected piece
setSelectedPiece(index);
Use code with caution.
}, [stepFunction, isDragging]);
// Handle piece deselection
const handlePieceDeselect = useCallback(() => {
setSelectedPiece(null);
setCurrentHeight(0);
}, []);
// Handle height slider change
const handleHeightChange = useCallback((newHeight) => {
if (selectedPiece === null) return;
// Update current height
setCurrentHeight(newHeight);

// Update step function
setStepFunction(prev => {
  const updated = [...prev];
  updated[selectedPiece] = {
    ...updated[selectedPiece],
    y: newHeight
  };
  
  // Normalize
  const normalized = normalizeHeights(updated);
  
  // Update current height to reflect normalization
  const normalizedHeight = normalized[selectedPiece].y;
  if (normalizedHeight !== newHeight) {
    setCurrentHeight(normalizedHeight);
  }
  
  // Calculate autoconvolution and update total height
  calculateAutoconvolution(normalized);
  updateTotalHeight(normalized);
  
  return normalized;
});
Use code with caution.
}, [selectedPiece, normalizeHeights, calculateAutoconvolution, updateTotalHeight]);
// Handle drag start
const handleDragStart = useCallback((event) => {
if (selectedPiece === null) return;
setIsDragging(true);

const chartRect = barChartRef.current.getBoundingClientRect();
const startY = event.clientY;
const startHeight = currentHeight;

const handleMouseMove = (moveEvent) => {
  // Calculate delta from start position
  const deltaY = startY - moveEvent.clientY;
  
  // Scale delta to height (higher = more height)
  const heightScale = MAX_HEIGHT / (chartRect.height * 0.8);
  const newHeight = Math.max(0, Math.min(MAX_HEIGHT * 2, startHeight + deltaY * heightScale));
  
  // Update height
  handleHeightChange(newHeight);
};

const handleMouseUp = () => {
  setIsDragging(false);
  
  // Remove event listeners
  document.removeEventListener('mousemove', handleMouseMove);
  document.removeEventListener('mouseup', handleMouseUp);
};

// Add event listeners
document.addEventListener('mousemove', handleMouseMove);
document.addEventListener('mouseup', handleMouseUp);
Use code with caution.
}, [selectedPiece, currentHeight, handleHeightChange]);
// Custom bar chart component
const CustomBarChart = () => {
return (
<div ref={barChartRef} className="w-full h-64 relative">
<ResponsiveContainer width="100%" height="100%">
<BarChart 
data={stepFunction} 
barCategoryGap={0} 
barGap={0}
>
<CartesianGrid strokeDasharray="3 3" />
<XAxis
dataKey="x"
type="number"
domain={[MIN_X, MAX_X]}
tickCount={11}
label={{ value: 'x', position: 'insideBottom', offset: -5 }}
/>
<YAxis
domain={[0, 'auto']}
label={{ value: 'f(x)', angle: -90, position: 'insideLeft' }}
/>
<Tooltip
formatter={(value) => [value.toFixed(2), 'f(x)']}
labelFormatter={(label) => x: ${Number(label).toFixed(4)}}
/>
<ReferenceLine y={0} stroke="#000" />
<ReferenceLine x={0} stroke="#000" />
<Bar dataKey="y" fill="#8884d8">
{stepFunction.map((entry, index) => (
<rect
key={bar-${index}}
fill={selectedPiece === index ? "#ff7300" : "#8884d8"}
cursor={selectedPiece === index ? 'ns-resize' : 'pointer'}
/>
))}
</Bar>
</BarChart>
</ResponsiveContainer>
{/* Invisible overlay for better click and drag handling */}
    <div 
      className="absolute inset-0 grid" 
      style={{ 
        gridTemplateColumns: `repeat(${numPieces}, 1fr)`,
        pointerEvents: 'auto'
      }}
    >
      {stepFunction.map((entry, index) => (
        <div
          key={`overlay-${index}`}
          className={`h-full ${selectedPiece === index ? 'cursor-ns-resize' : 'cursor-pointer'}`}
          onClick={() => handlePieceClick(index)}
          onMouseDown={(e) => {
            if (selectedPiece === index) {
              e.preventDefault();
              handleDragStart(e);
            } else {
              handlePieceClick(index);
            }
          }}
        />
      ))}
    </div>
  </div>
);
Use code with caution.
};
// Custom line chart for autoconvolution
const CustomLineChart = () => {
return (
<div className="w-full h-64">
<ResponsiveContainer width="100%" height="100%">
<LineChart data={autoconvolution}>
<CartesianGrid strokeDasharray="3 3" />
<XAxis
dataKey="x"
type="number"
domain={[-0.5, 0.5]}
tickCount={11}
label={{ value: 't', position: 'insideBottom', offset: -5 }}
/>
<YAxis
label={{ value: 'ff(t)', angle: -90, position: 'insideLeft' }}
/>
<Tooltip
formatter={(value) => [value.toFixed(4), 'ff(t)']}
labelFormatter={(label) => t: ${Number(label).toFixed(4)}}
/>
<ReferenceLine y={0} stroke="#000" />
<ReferenceLine x={0} stroke="#000" />
<ReferenceLine y={GOOGLE_BOUND} stroke="#FF0000" strokeDasharray="5 5" />
<Line
type="monotone"
dataKey="y"
stroke="#82ca9d"
dot={false}
isAnimationActive={false}
/>
</LineChart>
</ResponsiveContainer>
</div>
);
};
return (
<div className="flex flex-col p-4 space-y-4 max-w-5xl mx-auto">
<div className="text-2xl font-bold text-center">Step Function Autoconvolution</div>
{/* Controls */}
  <div className="bg-white p-4 rounded-lg shadow">
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div>
        <div className="mb-2">Number of Pieces: {numPieces}</div>
        <input
          type="range"
          min="5"
          max={MAX_PIECES}
          value={numPieces}
          onChange={(e) => setNumPieces(Number(e.target.value))}
          className="w-full"
        />
      </div>
      
      <div>
        <button
          onClick={generateRandomStepFunction}
          className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        >
          Regenerate Random
        </button>
      </div>
      
      <div>
        <div className="mb-2">Selected Piece: {selectedPiece !== null ? selectedPiece : 'None'}</div>
        {selectedPiece !== null && (
          <button
            onClick={handlePieceDeselect}
            className="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600"
          >
            Deselect
          </button>
        )}
      </div>
      
      <div>
        <div className="mb-2">Height Adjustment: {currentHeight.toFixed(2)}</div>
        <input
          type="range"
          min="0"
          max={MAX_HEIGHT * 2}
          step="0.1"
          value={currentHeight}
          onChange={(e) => handleHeightChange(Number(e.target.value))}
          className="w-full"
          disabled={selectedPiece === null}
        />
      </div>
    </div>
    
    <div className="mt-4">
      <div className="text-sm">Total Sum of Heights: {totalHeight.toFixed(2)}</div>
      <div className="text-sm text-gray-600">Target: 100</div>
    </div>
  </div>
  
  {/* Step Function Chart */}
  <div className="bg-white p-4 rounded-lg shadow">
    <div className="font-semibold mb-2">LP Step Function (P={numPieces})</div>
    <CustomBarChart />
  </div>
  
  {/* Autoconvolution Chart */}
  <div className="bg-white p-4 rounded-lg shadow">
    <div className="flex justify-between items-center mb-2">
      <div className="font-semibold">LP Autoconvolution f*f(t) (P={numPieces})</div>
      <div className="text-green-700">Max Value: {maxAutoconvValue.toFixed(4)}</div>
    </div>
    <CustomLineChart />
    <div className="text-sm mt-2 text-red-600">Google's bound: {GOOGLE_BOUND} (red line)</div>
  </div>
  
  {/* Instructions */}
  <div className="text-sm bg-gray-100 p-4 rounded">
    <strong>Instructions:</strong>
    <ol className="list-decimal pl-5">
      <li>Click on any bar to select it (turns orange)</li>
      <li>Drag selected bar up/down to adjust height or use the slider</li>
      <li>Heights automatically normalize to sum to 100</li>
      <li>The autoconvolution plot shows Google's bound at 1.5053</li>
    </ol>
  </div>
</div>
Use code with caution.
);
};
export default StepFunctionVisualizer;


For step func. 
$$f(x) = \sum_{i=0}^{P-1} h_i \mathbf{1}_{[x_i, x_{i+1})}(x)$$  
where
$$ x_i = -\frac{1}{4} + \frac{i}{2P}, \text{ and heights } h_i \ge 0:$$
\begin{align*}
% Integral
\text{Integral:}\quad \int_{-1/4}^{1/4} f(x) \,dx &= \frac{1}{2P} \sum_{i=0}^{P-1} h_i
\\[2ex]
% Autoconvolution
\text{Autoconv. knots:}\quad (f*f)(t_m) &= 
\begin{cases} 
0 & \text{if } m=0 \text{ or } m=2P \\
\frac{1}{2P} \sum_{k=\max(0, m-P)}^{\min(P-1, m-1)} h_k h_{m-1-k} & \text{if } 1 \le m \le 2P-1
\end{cases}
\\[0.5ex]
&\quad \text{where } t_m = -\frac{1}{2} + \frac{m}{2P} \quad (m=0, \dots, 2P).
\end{align*}