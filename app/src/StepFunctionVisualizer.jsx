import React, { useState, useEffect, useCallback, useRef } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ReferenceLine, ResponsiveContainer, BarChart, Bar } from 'recharts';

const StepFunctionVisualizer = () => {
  // Constants
  const MIN_X = -0.25;
  const MAX_X = 0.25;
  const DEFAULT_NUM_PIECES = 50;
  const MAX_PIECES = 600; // Increased to accommodate Google's solution
  const GOOGLE_BOUND = 1.5053;
  const MAX_HEIGHT = 100; // Increased from 20
  
  // Predefined step functions
  const GOOGLE_SOLUTION = [9.00854017233134, 4.581788824134047, 5.954983797866223, 3.7314786029786324, 4.25817159660483, 3.544987049547799, 0.08876194700959494, 0.0491697316439318, 1.7439263266999894, 3.8548164683263795, 3.621038728073569, 4.04587668218835, 4.68211946529981, 5.5904236142896675, 4.737832747546433, 3.1594093823451055, 1.902874129984629, 2.7870307391136304, 3.277574995692391, 1.8981329099596054, 1.526040859367755, 2.305128838504833, 5.17673786436095, 4.583218228762042, 3.9910761392791887, 2.784600928752006, 5.450687602543662, 6.170368723277989, 7.045569321986071e-16, 7.149948549556939e-15, 0.0, 0.0, 0.0, 0.0, 1.2580295353835013e-15, 0.0, 0.0, 0.0, 0.0, 3.873037303627252e-15, 0.0, 0.0, 2.020385656008168e-06, 0.000293922119342568, 0.0, 4.9514916125368726e-15, 7.282654612521097e-16, 1.906059354629418e-14, 0.0, 3.3528418595404916e-15, 1.5099558045700925e-15, 4.901439953827422e-15, 0.0, 8.851999542886555e-15, 0.0, 0.0, 0.0005211322699854395, 0.3757576289315001, 0.25176470069965495, 4.1179587840945515e-06, 0.0, 2.946431316197597e-15, 0.0, 1.0333089131925899e-16, 2.591940622467849e-15, 0.0, 6.852171628124262e-15, 0.0, 0.0, 1.3885601200927435e-14, 2.5015636739088256e-15, 1.4382184696274247e-14, 1.235388698636516e-15, 9.328196456283097e-15, 6.938490364750181e-15, 5.581796597296351e-17, 0.0, 0.0, 5.1220388613389905e-15, 0.0, 6.085199919293191e-15, 0.0, 0.0, 1.0633201915504476e-14, 6.240893078396387e-16, 0.0, 9.242385301100576e-15, 2.1818685641605435e-15, 0.0, 3.841626602268906e-15, 0.0013592097228050644, 8.120066974555713e-15, 8.479388423870961e-16, 2.5924005380166956e-15, 0.0, 2.6610672065525727e-15, 0.0, 1.233819156251431e-14, 8.819083406210366e-15, 0.0, 4.492323424835768e-16, 0.0, 3.0916450306058138e-15, 0.0, 0.0, 3.404186949211756e-15, 4.54126650881379e-15, 1.462631558763152e-14, 0.0, 0.0, 0.0, 1.4460597710909072e-15, 9.521734973996671e-15, 0.0, 4.559858799705722e-15, 7.864867909828807e-16, 0.0, 1.7856864350178655e-16, 0.00021045010164189585, 0.26541232693216404, 0.8094426381528257, 0.5750041584597478, 0.23313281323505236, 3.6007277514467585e-05, 0.0, 0.7828826491881691, 0.43382874037802, 1.3263698571911402, 0.5441713262465393, 0.9864380574571914, 0.6776516652004773, 0.5910950602641856, 0.507419190418916, 0.5231329501406576, 0.9391246115133585, 0.4508771959372286, 0.28283039994676146, 1.2889986480406397, 0.9649046182943108, 1.4104382244415803, 1.3916682358533747, 0.8743196646011149, 0.7627485335443527, 0.2103862254578538, 0.14545209168646947, 0.019762475547189184, 1.2279396984729254, 0.012006361768949678, 1.7677675926679783, 0.9303739918691369, 1.0966313889580412, 0.40142701455261154, 0.1477985748190306, 0.1310850821272394, 0.0027642064206369592, 0.6718883532064702, 0.287789791442545, 1.1886491680958895, 0.6459736548490735, 0.88966666001013, 0.36931312374260505, 0.6840914190936884, 0.38692129734520775, 0.8050006872194091, 0.26610729268169875, 0.002941709304056364, 0.5150673486621109, 0.4049854152265144, 1.1607178193685956, 1.7547854228356075, 0.0, 0.8531817250969695, 2.3845552035650363e-05, 0.035208188035124974, 0.06799207369201249, 0.14050016250524128, 0.4862562534194792, 1.508781726996261, 0.46943710673489225, 0.22962993226722195, 1.589825945710927e-11, 3.51517770993058e-15, 2.4398590319680178e-15, 1.1666504235544564e-06, 0.0021946672216711, 0.34171503722540436, 0.4703022197366691, 0.1313974666218601, 0.11754826815054241, 0.0, 2.2387234387833643e-16, 0.0, 7.192783695625604e-05, 0.4486935802226264, 1.234691190028419, 2.8985055264499153, 1.0234017394012231, 2.7375379465420373, 0.5899927642043619, 1.4461499611411766, 0.7033498408537826, 1.6505029216035125, 0.9593634797752735, 0.009302210703764222, 0.0004181359389419785, 0.0, 0.0, 0.0023430720926212976, 0.42801036705183393, 0.6031743194865573, 1.8862845950884395, 1.0944504439060767, 1.3978223736063145, 0.13603422891356853, 0.8568768273359568, 0.5287328963079988, 0.04201038853661816, 0.5746932650501643, 0.7698787794362285, 2.2478052766496255, 1.3267115762262056, 1.3819155415467284, 1.210307904386098, 1.2050374056121944, 0.973960636675429, 0.13506178694552, 0.0017211602091930576, 1.2080793667302383, 0.9431703684918005, 0.004927152124127672, 0.26457949335968395, 0.219096730428291, 0.8972094379125464, 1.009247390062118, 2.5396761105116816, 2.0567929964131704, 2.5384945885180765, 2.051772820060434, 2.841483226472209, 2.5484575236736253, 2.900405077014117, 2.7293223781158513, 2.8016507480694623, 2.5235338506952227, 2.842495616436774, 3.6113040879253218, 2.4409992918997654, 2.8613737519007785, 2.0376653653073236, 2.873716631081072, 2.7431139992026585, 2.3176851657187343, 2.963845077577065, 2.1297112056154828, 3.1281786712157276, 1.559962066888169, 1.5175735153572592, 1.8986372289826554, 2.422172211485286, 1.4024751115172904, 1.6645681102200025, 1.0890488631004245, 0.9551468779062758, 0.4210663124027455, 0.7844656815643463, 1.3849725648239561, 1.1400002207678432, 1.2589535564861496, 0.00010847583255872839, 0.33022246693439483, 0.009991411612394792, 3.897603693807049e-14, 0.0, 0.0, 4.615098985648224e-16, 0.0, 0.0, 0.00019552451607645426, 7.535959259635103e-15, 0.0, 0.0, 0.0, 3.391322478636254e-15, 0.0, 5.23262076392476e-16, 0.0, 0.0013138779575907105, 3.8754445450268335e-05, 0.6732744675805906, 0.1403000505612687, 0.1066587972153134, 3.248799681911591e-05, 0.0002955183459383166, 0.003362359949825627, 1.258993392593319, 0.6721840514813638, 1.4023077519116312, 0.26971646568749497, 1.5317811712427716e-06, 0.0, 0.0004643255998670316, 0.21977013225378167, 0.4192480303816599, 1.5193826730071023, 1.140986767032434e-14, 0.00023172541086911792, 0.0, 2.8126101180648514e-16, 0.3250641832764737, 0.2631639184319745, 9.581064115586714e-06, 6.911241239536039e-08, 2.1977413193942923e-15, 0.0, 0.009284626840990289, 0.38181362260215157, 0.9229241174303233, 1.2389265199825776, 4.003701357117134e-15, 0.0018347819223694948, 0.09741977675536181, 0.7177732728524777, 0.893918190086622, 0.7592094697415344, 0.33941833076021116, 0.9895237780462212, 1.2103201657651075, 0.1562357060123791, 0.05779942219135546, 0.046035988201598356, 0.20605598834789451, 0.7087789468745198, 0.9835248618606901, 0.15343068950958472, 0.7458575667928422, 1.1650897270704061, 0.8603305066335794, 0.21035575411632462, 0.1359607526732069, 0.27083984880209855, 0.6401471037748572, 3.021195033008772e-11, 0.2302514662496976, 0.6133656015904811, 0.0014526177283533382, 0.2833008515927792, 0.6173666814379335, 0.35174441102605253, 0.42994053621927014, 0.17019592622467353, 0.18730260272562482, 0.20732692125660646, 0.0006488239072035948, 0.0008689690193708769, 0.0060827028748053225, 0.42803050608386095, 0.5802023431307022, 0.07735146147149399, 0.2677857202504946, 0.0009184606747345728, 0.43037124020293993, 0.3617534843366182, 0.3772422594534307, 0.2584947755294139, 0.001169636807952639, 1.9643151751270573e-08, 0.0, 0.0, 0.0, 2.0182994696828576e-15, 0.06977916421885891, 0.2579938169821856, 0.37671532887212333, 0.024565028057913885, 0.12617825469188657, 0.6340448467030686, 0.5754643941945634, 0.13048109721771595, 1.4341543078480776, 1.3216214397106167, 0.4415648326891368, 0.8216927039920507, 0.9032727935119587, 1.7656705299211204, 1.627512140396068, 1.5918752695978569, 2.051239519025683, 1.9657798505455604, 2.8356702084496526, 2.5590427999121284, 2.982526516926714, 2.6272105137933197, 2.960027241401188, 3.3362990605756897, 3.131536821850587, 3.159111523746814, 2.7752077904104517, 1.0508812833436538, 0.21463498939778325, 0.6073490769165661, 0.267278502966685, 0.3440305423365897, 1.0124744653679076, 1.342256457731422, 0.2717826360960419, 1.6632114845610049, 1.7120322558818795, 1.575579186781418, 2.202279058543633, 2.005531691208538, 1.891973046186819, 2.2982791457282916, 2.4252951011748562, 1.3467523990450576, 1.394123734140854, 1.306121994024973, 1.3563331357893305, 1.908587215779497, 2.2410142807813824, 2.1400334226110425, 2.0238641943935187, 2.4448713165408282, 0.001517101822563153, 9.482987339023494e-15, 0.0, 1.5827373963789938e-15, 1.580023867552888, 2.5839838573569534, 1.5871346370389885, 4.1337617125689725, 0.0016876790012300346, 2.337637442823331, 1.9268402331708496, 2.509223443618991, 2.8573979857307554, 2.7429627532040692, 2.3184117402885605, 2.2519888495692886, 1.441733890843454, 2.3283267069330638, 2.090507069768287, 1.616388780668859, 0.30852077577914405, 1.2418308849676503, 0.749579822648432, 2.0216862557918627, 1.8471265276557536, 1.9409844374088654, 2.029630658555306, 1.7488835640200255, 1.4429217698293368, 0.09853693097516952, 1.5685094105495399, 0.060035092997817674, 1.1562109869575399, 0.9883011451997243, 1.257630809337659, 1.6997562951967606, 0.4508041502784602, 0.3164090446061367, 1.4182969827012353, 1.3595162629204571, 1.475081471520821, 3.021289456736385, 3.0956206508951407, 2.481681959913101, 2.1308362149915583, 2.9008847410243757, 2.909122424144527, 2.7204695218309363, 2.087469496170989, 1.3538856364999683, 0.2008306196121235, 1.600964614957816, 1.4250387287265247, 1.6911311698607534, 1.1526705582269934, 0.7292975452608408, 0.4173852602091413, 0.2662677349829448, 1.5122097133171966, 1.0836674077065491, 1.031414686946613, 0.8173974802808452, 0.7095506482976092, 0.5949976898998941, 0.29670773819783247, 0.5083829941296425, 0.6440505445429058, 0.053833868680306, 7.794970013943188e-16, 0.7045208512938965, 1.6120699276991068, 1.5318231382310976, 1.7340273755678486, 2.4381603392169247, 2.6170276892155027, 2.5906147953962844, 3.407886846404895, 3.6212633825479905, 2.329416094716585, 2.958660792491976, 2.6669305434977773, 2.1590860132417564, 2.4937418622856145, 2.5589089762124786, 1.3338118137548678, 1.1942787402156965, 1.7418035300505763, 1.4081188229888932, 1.2487225960375548, 1.4492676314261193, 1.2654783371285574, 1.1685912162797853, 1.0148303874944786, 1.1962440020710763, 1.305708313372589, 0.6602148155530632, 0.337166044389861, 0.8396055147211476, 0.8562349502018103, 0.588778548048956, 0.7049070769530035, 1.2538977263308646, 1.4831897704424597, 1.4593441911500031, 2.1621717599542505, 2.4273857543891015, 2.426355640271325, 2.83832034285733, 2.7641303296460444, 2.2050969080359004, 2.6355562577584215, 3.1005626046243817, 2.4089187966341488, 1.8919645338161346, 1.8840157076492403, 1.344761629829863, 1.404294123950026, 1.8721961393692923, 1.3226408636613955, 0.4215497636181964, 0.5726863357586803, 1.0258923965461795, 1.1819610363504558, 0.8368490648663582, 0.6515561348082733, 0.6685731745760881, 0.5334870649826413, 0.8710519187832059, 0.6669646197224997, 0.5260752114304805, 0.3876797985565807, 0.03621327582895155, 0.46897871650384915, 0.8718533580569904, 0.7009452451531725, 1.4931853849244896, 1.8652719440498333, 1.6631794982365034, 1.494779190512575, 2.508688004725345, 3.0433643835464537, 3.2533878501144433, 3.579790260747532, 2.164640103097207, 0.6698924809914789, 2.1342050222506663, 2.5814605344559984, 1.6583152357630657, 1.3111552900920307, 1.20851491437197, 0.3334479204279151, 0.0027238985981172218, 0.7485037657977041, 0.23706880539492062, 0.3990097623354095, 4.751136081369487e-05, 1.5362095500430528, 0.46926869783190056, 0.0007246232360620678, 0.0, 5.239717734593537e-16, 9.938359637204445e-16, 0.0, 1.7385067095755083e-16, 4.106727240038999e-15, 0.10511094949367368, 0.026846967487429776, 0.0796163088839284, 0.8797518497354565, 2.616397453997683, 3.9912371044774604, 3.6233174077890604, 1.5672138389164023, 1.8304904251881515, 2.748948532497653, 3.287747311072218, 4.0926517829783675, 6.029811160308903];

  // Smooth solution 
  const SMOOTH_SOLUTION = [0.0312468817707471, 0.0991993007530676, 0.3146144132762271, 0.8081900307546818, 1.5548905520644511, 2.2167847619586309, 2.4306992358107480, 2.2721125663211121, 2.1325317684007024, 2.2168139357002681, 2.4297848181962460, 2.6150458936331491, 2.7088538259368238, 2.7311810261656553, 2.7319621003827050, 2.7519969096017007, 2.8063364658514174, 2.8864514189627526, 2.9726796244089884, 3.0470554476689173, 3.1004193207053130, 3.1330793095565213, 3.1515425621079314, 3.1642736359761265, 3.1783723933926038, 3.1978468537193767, 3.2233661401170317, 3.2530237189306184, 3.2835650045623259, 3.3116117696045122, 3.3345721045002508, 3.3511019856732762, 3.3611367501404796, 3.3656092998452376, 3.3660099783937016, 3.3639320001935062, 3.3607059982855794, 3.3571774717951333, 3.3536360137934675, 3.3498727564550435, 3.3453244437732366, 3.3392573591896486, 3.3309487627308716, 3.3198338972226713, 3.3055996662717018, 3.2882190478475803, 3.2679312225911996, 3.2451800930308496, 3.2205279261990696, 3.1945614810865584, 3.1678058597350129, 3.1406573798996122, 3.1133419983349646, 3.0859010992726961, 3.0582024681223161, 3.0299713965307649, 3.0008352533337694, 2.9703744339945257, 2.9381731479293842, 2.9038647202850170, 2.8671676595713067, 2.8279103958984027, 2.7860441102856988, 2.7416443125501351, 2.6949027154912120, 2.6461114893564206, 2.5956421998913024, 2.5439216987924120, 2.4914070203078005, 2.4385610129595703, 2.3858300613588845, 2.3336248758720806, 2.2823049783874190, 2.2321672080424020, 2.1834383183219264, 2.1362715359451272, 2.0907467976965131, 2.0468742673082327, 2.0046006540636458, 1.9638178022610304, 1.9243729916243861, 1.8860803799916934, 1.8487330289207333, 1.8121149785671515, 1.7760128788322971, 1.7402267377505036, 1.7045794134636123, 1.6689245505770178, 1.6331527424644339, 1.5971957851307792, 1.5610289723240023, 1.5246714624755628, 1.4881848226914267, 1.4516699207002994, 1.4152623901693206, 1.3791269364892780, 1.3434507780407701, 1.3084365317931970, 1.2742948522394804, 1.2412371201203851, 1.2094684536548297, 1.1791812819881065, 1.1505496805009052, 1.1237246228372846, 1.0988302573711128, 1.0759612685891535, 1.0551813385595030, 1.0365226820094997, 1.0199865919295972, 1.0055449020277221, 0.9931422483609542, 0.9826989952642363, 0.9741146801314147, 0.9672718272447117, 0.9620399820325373, 0.9582798230468217, 0.9558472186919008, 0.9545971083944800, 0.9543871026097084, 0.9550807120353689, 0.9565501330060422, 0.9586785327626733, 0.9613617947989327, 0.9645097005862325, 0.9680465396239292, 0.9719111550118670, 0.9760564467385713, 0.9804483697958940, 0.9850644792332829, 0.9898920894477173, 0.9949261303341365, 1.0001667981623366, 1.0056171136946155, 1.0112805132655620, 1.0171586090596403, 1.0232492609545807, 1.0295451019364366, 1.0360326497865329, 1.0426921168941257, 1.0494979952278418, 1.0564204428804731, 1.0634274315416929, 1.0704875319361093, 1.0775731203473997, 1.0846636904822040, 1.0917488609862769, 1.0988305927987514, 1.1059240873026286, 1.1130568416738460, 1.1202654062238604, 1.1275895299431045, 1.1350635978375552, 1.1427055501871368, 1.1505038111243830, 1.1584031115071427, 1.1662904279852726, 1.1739825285754202, 1.1812167658425066, 1.1876467487324665, 1.1928443236477895, 1.1963088956622341, 1.1974845387297532, 1.1957846237202061, 1.1906229045332370, 1.1814492331190036, 1.1677874194314442, 1.1492723023572728, 1.1256829239229305, 1.0969688424219988, 1.0632670828232216, 1.0249079661385525, 0.9824090071348571, 0.9364571176633809, 0.8878803826956200, 0.8376115717615991, 0.7866462117537264, 0.7359984108488349, 0.6866576595804309, 0.6395495570293411, 0.5955028680685087, 0.5552245900666384, 0.5192838885136782, 0.4881049467352876, 0.4619680506133359, 0.4410176599868350, 0.4252758429165758, 0.4146592783798863, 0.4089980533117044, 0.4080546579062097, 0.4115418733571887, 0.4191385990079626, 0.4305030339974626, 0.4452829724766303, 0.4631232627706984, 0.4836707028551504, 0.5065767917637060, 0.5314988327959757, 0.5580998998499422, 0.5860481467059324, 0.6150158755443158, 0.6446786993857255, 0.6747150452768959, 0.7048061598195627, 0.7346367020113812, 0.7638959436428566, 0.7922795458620472, 0.8194918416656715, 0.8452485267701569, 0.8692796438965599, 0.8913327362298422, 0.9111760430930397, 0.9286016133727377, 0.9434282188844733, 0.9555039598608641, 0.9647084674513131, 0.9709546230252770, 0.9741897307107609, 0.9743960975229826, 0.9715909941715618, 0.9658259886731955, 0.9571856637081468, 0.9457857466975969, 0.9317706983084014, 0.9153108200086699, 0.8965989539565408, 0.8758468585401815, 0.8532813500319782, 0.8291403049167667, 0.8036686184619644, 0.7771142130924528, 0.7497241853014890, 0.7217411724572642, 0.6934000113234149, 0.6649247488367002, 0.6365260531561758, 0.6083990597173193, 0.5807216734933783, 0.5536533353653299, 0.5273342478719780, 0.5018850440383058, 0.4774068727807713, 0.4539818658044421, 0.4316739441000353, 0.4105299171996021, 0.3905808252608737, 0.3718434727540398, 0.3543221028906192, 0.3380101637804175, 0.3228921204083387, 0.3089452706404328, 0.2961415283363736, 0.2844491419997496, 0.2738343229830765, 0.2642627628441905, 0.2557010248133232, 0.2481177992958297, 0.2414850177598807, 0.2357788231348039, 0.2309803979058453, 0.2270766534040403, 0.2240607853602298, 0.2219327016569600, 0.2206993284367013, 0.2203748003994095, 0.2209805403564930, 0.2225452320260223, 0.2251046887894612, 0.2287016198218535, 0.2333852937932947, 0.2392110993521238, 0.2462400009615680, 0.2545378884781780, 0.2641748192189888, 0.2752241522273319, 0.2877615760488681, 0.3018640335725638, 0.3176085503449693, 0.3350709761638794, 0.3543246535973351, 0.3754390312195754, 0.3984782436390302, 0.4234996846196912, 0.4505526035502825, 0.4796767589667972, 0.5109011655508988, 0.5442429727846002, 0.5797065140345163, 0.6172825640918711, 0.6569478409748526, 0.6986647840288928, 0.7423816350215380, 0.7880328420749096, 0.8355397980367764, 0.8848119154614316, 0.9357480300248076, 0.9882381132686282, 1.0421652644416657, 1.0974079403045869, 1.1538423715290438, 1.2113451051896689, 1.2697956052332575, 1.3290788370799027, 1.3890877589662951, 1.4497256414965300, 1.5109081382360190, 1.5725650340771986, 1.6346416044192678, 1.6970995267310447, 1.7599172965068197, 1.8230901116083300, 1.8866292020948741, 1.9505605964483712, 2.0149233291939703, 2.0797671089527490, 2.1451494796893416, 2.2111325212069661, 2.2777791478130145, 2.3451490766987750, 2.4132945502540926, 2.4822559096820842, 2.5520571313415079, 2.6227014526257579, 2.6941672311157960, 2.7664041991270243, 2.8393302950243222, 2.9128292715577553, 2.9867492979012522, 3.0609027830444870, 3.1350676497058916, 3.2089902751300237, 3.2823902825106130, 3.3549673086954512, 3.4264097851888464, 3.4964056466717293, 3.5646547233295269, 3.6308823830865431, 3.6948537753085473, 3.7563878025733715, 3.8153697321610505, 3.8717611807829759, 3.9256060969201045, 3.9770313605676231, 4.0262407563547393, 4.0735013860253853, 4.1191220959233332, 4.1634242181827341, 4.2067058571714604, 4.2492020679673974, 4.2910445117519140, 4.3322254313612145, 4.3725719096246971, 4.4117371242019496, 4.4492153888314849, 4.4843867990044650, 4.5165948838516004, 4.5452564781413081, 4.5699969573546593, 4.5907963192450456, 4.6081232376444872, 4.6230267604364341, 4.6371510288284226, 4.6526398457438045, 4.6719074109345584, 4.6972702098538983, 4.7304619816300875, 4.7720853154769101, 4.8210834892243914, 4.8743366623833628, 4.9264895128751576, 4.9700973472891574, 4.9961338662471766, 4.9948415533682438, 4.9568364765902357, 4.8743183979118818, 4.7421998948245134, 4.5589659658552080, 4.3271118418237604, 4.0530755989619163, 3.7466694701044321, 3.4201004488742170, 3.0867380186926749, 2.7598208569874614, 2.4512898836378478, 2.1708960785215705, 1.9256696570926255, 1.7197679014846816, 1.5546572127437228, 1.4295417804976098, 1.3419316761773388, 1.2882461221079289, 1.2643675633075653, 1.2660911248027085, 1.2894443290166595, 1.3308776532909214, 1.3873443386631557, 1.4562971043631314, 1.5356312852143581, 1.6236006232652893, 1.7187259371093393, 1.8197102034456500, 1.9253675934431853, 2.0345694051385115, 2.1462067713352528, 2.2591683056157650, 2.3723301283560536, 2.4845556257671952, 2.5947025367150136, 2.7016353245175750, 2.8042411511929854, 2.9014480736272046, 2.9922443118999702, 3.0756976095477029, 3.1509738325960410, 3.2173540578171598, 3.2742494962004431, 3.3212136954606115, 3.3579515712287504, 3.3843249322086377, 3.4003542889913758, 3.4062168663846708, 3.4022408707736145, 3.3888961922997596, 3.3667818414914810, 3.3366105266210266, 3.2991908672974435, 3.2554078082537550, 3.2062018425879835, 3.1525476746335399, 3.0954329490945716, 3.0358376461532326, 2.9747146940502076, 2.9129722841629757, 2.8514582925646272, 2.7909471206223242, 2.7321291698091641, 2.6756030669753814, 2.6218706600488431, 2.5713347142840339, 2.5242991589453658, 2.4809716661915107, 2.4414682896552558, 2.4058198507369424, 2.3739797361374770, 2.3458327601420192, 2.3212047485186864, 2.2998725160261357, 2.2815739344858010, 2.2660178210097106, 2.2528934140399457, 2.2418792461449422, 2.2326512649655119, 2.2248900954678783, 2.2182873761838118, 2.2125511381607752, 2.2074102270039657, 2.2026177950919448, 2.1979539125196297, 2.1932273615693494, 2.1882766907629403, 2.1829706112142442, 2.1772078206199410, 2.1709163394158475, 2.1640524400412540, 2.1565992445505788, 2.1485650586140821, 2.1399815018283381, 2.1309014857155399, 2.1213970822545143, 2.1115573176035940, 2.1014859181181595, 2.0912990290367230, 2.0811229204506012, 2.0710916904744452, 2.0613449719468662, 2.0520256465281399, 2.0432775687149536, 2.0352433020291274, 2.0280618704086031, 2.0218665295681086, 2.0167825657189367, 2.0129251324370054, 2.0103971405175098, 2.0092872201977858, 2.0096677799836495, 2.0115931912638430, 2.0150981326978892, 2.0201961327430777, 2.0268783523533491, 2.0351126525302128, 2.0448429927254717, 2.0559892057913562, 2.0684471929776653, 2.0820895781653341, 2.0967668539423197, 2.1123090431929219, 2.1285278886042036, 2.1452195690213838, 2.1621679261549454, 2.1791481681251974, 2.1959309982151889, 2.2122870985922973, 2.2279918803513983, 2.2428303938018241, 2.2566022772865728, 2.2691266098183722, 2.2802465232514946, 2.2898334243236080, 2.2977906763353761, 2.3040565949783129, 2.3086066231833375, 2.3114545659415313, 2.3126527877086125, 2.3122913018619906, 2.3104957131010426, 2.3074240087943019, 2.3032622329901127, 2.2982191158432270, 2.2925197701509630, 2.2863986040337347, 2.2800916330040355, 2.2738284042524213, 2.2678237695523005, 2.2622697595333996, 2.2573278202169869, 2.2531216719522367, 2.2497310408815157, 2.2471864937924888, 2.2454655790615838, 2.2444904401047356, 2.2441270244298326, 2.2441859624520366, 2.2444251373763096, 2.2445539125617766, 2.2442389278770913, 2.2431113236949001, 2.2407752023730065, 2.2368170942149552, 2.2308161596650704, 2.2223548332568726, 2.2110295986340351, 2.1964615784391617, 2.1783066282318582, 2.1562646396343315, 2.1300877839653132, 2.0995874626720878, 2.0646397735177597, 2.0251893500530693, 1.9812514845147857, 1.9329124989345041, 1.8803283838618141, 1.8237217767028095, 1.7633774003803055, 1.6996361261762452, 1.6328878608335176, 1.5635634862106962, 1.4921260992920193, 1.4190618108226563, 1.3448703623020211, 1.2700558139143525, 1.1951175409134907, 1.1205417539864240, 1.0467937313920710, 0.9743109185548636, 0.9034970157189541, 0.8347171376903750, 0.7682940930207574, 0.7045057945266888, 0.6435837799562327, 0.5857127918870085, 0.5310313403356216, 0.4796331506183314, 0.4315693830421232, 0.3868515001166186, 0.3454546510506484, 0.3073214420430183, 0.2723659638561662, 0.2404779548199518, 0.2115269871165360, 0.1853665762671150, 0.1618381274876420, 0.1407746474084384, 0.1220041691103263, 0.1053530145666216, 0.0906530561688323, 0.0778232761710261, 0.0677874112759254, 0.0692656392271148, 0.1290062701887976, 0.3982162245063003, 1.1285984561004490, 2.3505692806998306, 3.4405175487896069, 3.5600464955037046, 3.5194533544400191, 9.0289750460157876, 24.6178536581834422, 31.0651684662629854, 16.3792211437666566, 3.5759660853223822, 0.3268693794059615];

  // Matolcsi Vinuesa 2010 solution
  const MATOLCSI_VINUESA_SOLUTION = [
    1.21174638, 0, 0, 0.25997048, 0.47606812,
    0.62295219, 0.3296586, 0, 0.29734381, 0,
    0, 0, 0, 0, 0,
    0, 0.00846453, 0.05731673, 0, 0.13014906,
    0, 0.08357863, 0.05268549, 0.06456956, 0.06158231,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 
    0.02396999, 0, 0, 0.05846552, 0,
    0, 0, 0, 0, 0.0026332,
    0.0509835, 0, 0.1283313, 0.0904924, 0.21232176,
    0.24866151, 0.09933512, 0.01963586, 0.01363895, 0.32389841,
    0, 0, 0.14467517, 0.0129752, 0,
    0, 0.16299837, 0.38329665, 0.11361262, 0.32074656,
    0.17344291, 0.33181372, 0.24357561, 0.2577003, 0.20567824,
    0.13085743, 0.17116496, 0.14349025, 0.07019695, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0.0131741, 0.0342541, 0.0427565, 0.03045044,
    0.07900079, 0.07020678, 0.08528342, 0.09705597, 0.0932896,
    0.09360206, 0.06227754, 0.07943462, 0.08176106, 0.10667185,
    0.10178412, 0.11421821, 0.07773213, 0.11021377, 0.12190377,
    0.06572457, 0.07494855, 0, 0, 0.02140202,
    0, 0, 0.0231478, 0.00127997, 0,
    0.04672881, 0.03886266, 0.11141784, 0.00695668, 0.0466224,
    0.03543131, 0.08803511, 0.04165729, 0.10785652, 0.06747342,
    0.18785215, 0.31908323, 0.3249705, 0.09824861, 0.23309878,
    0.12428441, 0.03200975, 0.0933163, 0.09527521, 0.12202693,
    0.13179059, 0.09266878, 0.02013746, 0.16448047, 0.20324945,
    0.21810431, 0.27321179, 0.25242816, 0.19993811, 0.13683837,
    0.13304836, 0.08794214, 0.12893672, 0.16904485, 0.22510883,
    0.26079786, 0.27367504, 0.26271896, 0.20457964, 0.15073917,
    0.11014028, 0.09896, 0.0926069, 0.13269111, 0.17329988,
    0.20761774, 0.21707182, 0.18933169, 0.14601258, 0.08531506,
    0.06187865, 0.06100211, 0.09064962, 0.12781018, 0.17038096,
    0.185766, 0.1734501, 0.14667009, 0.09569536, 0.06092822,
    0.03219067, 0.0495587, 0.09657756, 0.16382398, 0.22606693,
    0.22230709, 0.19833621, 0.16155032, 0.09330751, 0.02838363,
    0.02769322, 0.03349924, 0.09448887, 0.20517242, 0.22849741,
    0.24175836, 0.19700135, 0.18168723
  ];

  // State variables
  const [numPieces, setNumPieces] = useState(DEFAULT_NUM_PIECES);
  const [stepFunction, setStepFunction] = useState([]);
  const [autoconvolution, setAutoconvolution] = useState([]);
  const [selectedPiece, setSelectedPiece] = useState(null);
  const [currentHeight, setCurrentHeight] = useState(0);
  const [totalHeight, setTotalHeight] = useState(0);
  const [maxAutoconvValue, setMaxAutoconvValue] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [notification, setNotification] = useState({ show: false, message: '', type: 'success' });
  const [copyFormat, setCopyFormat] = useState('csv'); // 'csv', 'python', or 'raw'
  
  // Zoom state
  const [zoomDomain, setZoomDomain] = useState({ xMin: MIN_X, xMax: MAX_X });
  const [isZoomed, setIsZoomed] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1); // For manual zoom controls
  const [freeScrolling, setFreeScrolling] = useState(true); // Allow unrestricted panning, now enabled by default
  
  // Save state for different configurations
  const [savedStates, setSavedStates] = useState({
    random: null,
    google: null,
    matolcsi: null,
    smooth: null
  });
  
  // Track current selected configuration
  const [currentConfig, setCurrentConfig] = useState('random');
  
  // Refs
  const barChartRef = useRef(null);
  
  // Reference to store the current values for debounced operations
  const stateRef = useRef({
    autoConvTimeout: null,
    maxAutoTimeout: null,
    stepFunction: []
  });
  
  // Move these up before the functions are defined
  const [isInitialized, setIsInitialized] = useState(false);
  const [lastManualPiecesChange, setLastManualPiecesChange] = useState(0);
  
  // We'll add the initialization effect after all the functions are defined
  
  // Update max autoconvolution value when autoconvolution changes
  useEffect(() => {
    if (autoconvolution.length > 0) {
      try {
        // Get all y values, filtering out any NaN or infinite values
        const validYValues = autoconvolution
          .map(point => point.y)
          .filter(y => isFinite(y) && !isNaN(y));
        
        // If we have valid values, calculate max
        if (validYValues.length > 0) {
          const maxVal = Math.max(...validYValues);
          // Ensure we don't set NaN or infinite values
          if (isFinite(maxVal) && !isNaN(maxVal)) {
            setMaxAutoconvValue(maxVal);
          } else {
            console.warn("Invalid max value calculated, using default");
            setMaxAutoconvValue(1.0); // Safe default
          }
        } else {
          console.warn("No valid y values found in autoconvolution data");
          setMaxAutoconvValue(1.0); // Safe default
        }
      } catch (error) {
        console.error("Error calculating max autoconvolution value:", error);
        setMaxAutoconvValue(1.0); // Safe default
      }
    }
  }, [autoconvolution]);
  
  // Define calculation functions separately to avoid circular dependencies
  
  // Calculate autoconvolution without dependencies on React state - completely redesigned for stability
  const calculateAutoconvolutionData = (steps) => {
    try {
      // Use the actual number of steps
      const P = steps.length;
      if (P <= 0) {
        console.error("No steps provided to calculateAutoconvolutionData");
        return generateEmptyAutoconvolutionData(P);
      }
      
      // Extract heights with safety checks
      const heights = steps.map(step => {
        if (step === undefined || step === null) return 0;
        const height = Number(step.y);
        return isNaN(height) ? 0 : Math.max(0, height); // Ensure non-negative numbers
      });
      
      // Check if we have any non-zero heights
      const totalHeight = heights.reduce((sum, h) => sum + h, 0);
      if (totalHeight <= 0.001) {
        console.warn("All heights are essentially zero, returning empty autoconvolution");
        return generateEmptyAutoconvolutionData(P);
      }
      
      // Calculate piece width
      const pieceWidth = 1/(2*P);
      
      // Calculate normalized heights (so sum equals 1)
      const normalizedHeights = heights.map(h => h / totalHeight);
      
      // Initialize result array
      const result = [];
      
      // Calculate autoconvolution at each point
      for (let m = 0; m <= 2 * P; m++) {
        const t = -0.5 + m / (2 * P);
        let value = 0;
        
        // Skip computation for boundary points
        if (m === 0 || m === 2 * P) {
          value = 0;
        } else {
          const kMin = Math.max(0, m - P);
          const kMax = Math.min(P - 1, m - 1);
          
          // Calculate raw convolution sum
          for (let k = kMin; k <= kMax; k++) {
            value += normalizedHeights[k] * normalizedHeights[m - 1 - k];
          }
          
          // Apply scaling factor based on piece width
          value = value / pieceWidth;
          
          // Safety check for invalid values
          if (!isFinite(value) || isNaN(value)) {
            console.warn(`Invalid autoconvolution value at t=${t}, setting to 0`);
            value = 0;
          }
        }
        
        result.push({
          x: t,
          y: value
        });
      }
      
      return result;
    } catch (error) {
      console.error("Error in autoconvolution calculation:", error);
      // Return a safe fallback
      return generateEmptyAutoconvolutionData(steps?.length || 100);
    }
  };
  
  // Helper to generate empty autoconvolution data
  const generateEmptyAutoconvolutionData = (P = 100) => {
    const result = [];
    for (let m = 0; m <= 2 * P; m++) {
      const t = -0.5 + m / (2 * P);
      result.push({
        x: t,
        y: 0
      });
    }
    return result;
  };
  
  // Calculate total height
  const calculateTotalHeight = (steps) => {
    return steps.reduce((acc, step) => acc + step.y, 0);
  };
  
  // Wrapper function that updates state
  const calculateAutoconvolution = useCallback((steps) => {
    const result = calculateAutoconvolutionData(steps);
    setAutoconvolution(result);
  }, []);
  
  // Update total height
  const updateTotalHeight = useCallback((steps) => {
    const sum = calculateTotalHeight(steps);
    setTotalHeight(sum);
  }, []);
  
  // Define function to create a step function from heights
  const createStepFunction = (heights) => {
    try {
      // Validate input
      if (!Array.isArray(heights)) {
        console.error("Heights must be an array:", heights);
        return [];
      }
      
      const pieces = heights.length;
      if (pieces <= 0) {
        console.error("Heights array is empty");
        return [];
      }
      
      console.log(`Creating step function with ${pieces} pieces`);
      
      const pieceWidth = (MAX_X - MIN_X) / pieces;
      let newStepFunction = [];
      
      for (let i = 0; i < pieces; i++) {
        const x = MIN_X + (i + 0.5) * pieceWidth;
        // Ensure height value is valid
        const height = heights[i] !== undefined ? Number(heights[i]) : 0;
        
        newStepFunction.push({
          x,
          y: isNaN(height) ? 0 : Math.max(0, height), 
          pieceIndex: i,
          width: pieceWidth
        });
      }
      
      return newStepFunction;
    } catch (error) {
      console.error("Error creating step function:", error);
      return [];
    }
  };

  // Function to save current state before switching
  const saveCurrentState = useCallback(() => {
    if (!stepFunction.length) return;
    
    // Create a copy of the current state
    const stateToSave = {
      stepFunction: [...stepFunction],
      numPieces,
      selectedPiece,
      currentHeight,
      autoconvolution: [...autoconvolution],
      totalHeight,
      maxAutoconvValue,
      zoomDomain: { ...zoomDomain },
      isZoomed
    };
    
    // Save the current state
    setSavedStates(prev => ({
      ...prev,
      [currentConfig]: stateToSave
    }));
  }, [stepFunction, numPieces, selectedPiece, currentHeight, autoconvolution, totalHeight, maxAutoconvValue, zoomDomain, isZoomed, currentConfig]);
  
  // Function to load predefined solutions or saved state
  const loadPredefinedSolution = useCallback((type) => {
    // Save current state before switching
    saveCurrentState();
    
    // If we have a saved state for this type, use it
    if (savedStates[type]) {
      const savedState = savedStates[type];
      
      setStepFunction(savedState.stepFunction);
      setNumPieces(savedState.numPieces);
      setSelectedPiece(savedState.selectedPiece);
      setCurrentHeight(savedState.currentHeight);
      setAutoconvolution(savedState.autoconvolution);
      setTotalHeight(savedState.totalHeight);
      setMaxAutoconvValue(savedState.maxAutoconvValue);
      
      // Restore zoom state if available
      if (savedState.zoomDomain) {
        setZoomDomain(savedState.zoomDomain);
        setIsZoomed(savedState.isZoomed || false);
      }
      
      // Update current config
      setCurrentConfig(type);
      return;
    }
    
    // Otherwise, create a new state
    let heights;
    if (type === 'google') {
      heights = GOOGLE_SOLUTION;
    } else if (type === 'smooth') {
      heights = SMOOTH_SOLUTION;
    } else {
      heights = MATOLCSI_VINUESA_SOLUTION;
    }
    
    const newStepFunction = createStepFunction(heights);
    
    // Update everything at once
    setStepFunction(newStepFunction);
    setSelectedPiece(null);
    setCurrentHeight(0);
    setNumPieces(heights.length);
    
    // Calculate derived values
    const result = calculateAutoconvolutionData(newStepFunction);
    setAutoconvolution(result);
    setTotalHeight(calculateTotalHeight(newStepFunction));
    
    // Update current config
    setCurrentConfig(type);
  }, [savedStates, saveCurrentState]);
  
  // Generate random step function
  const generateRandomStepFunction = useCallback(() => {
    // Save current state before generating new one if applicable
    if (currentConfig !== 'random') {
      saveCurrentState();
    }
    
    try {
      console.log("Generating random step function with pieces:", numPieces);
      
      // Validate number of pieces to ensure it's a positive integer
      const pieces = Math.max(5, Math.floor(Number(numPieces))); 
      if (isNaN(pieces) || pieces <= 0) {
        console.error("Invalid number of pieces:", numPieces);
        return; // Don't proceed with invalid input
      }
      
      const pieceWidth = (MAX_X - MIN_X) / pieces;
      let heights = [];
      
      // Generate completely random heights with no pattern
      // Pre-allocate the array to avoid potential reflow issues
      heights = new Array(pieces);
      
      // Fill the array with random values
      for (let i = 0; i < pieces; i++) {
        // Use a distribution that gives more variety of heights
        // Random value between 0.1 and 5
        heights[i] = 0.1 + Math.random() * 4.9;
      }
      
      // Ensure we have some higher values scattered throughout
      const numHighValues = Math.min(10, Math.floor(pieces * 0.1)); // Up to 10% of pieces or 10, whichever is smaller
      
      for (let i = 0; i < numHighValues; i++) {
        const randomIndex = Math.floor(Math.random() * pieces);
        heights[randomIndex] = 5 + Math.random() * 5; // Higher values (5-10) at random positions
      }
      
      // Create step function
      const newStepFunction = createStepFunction(heights);
      
      // Update state
      setStepFunction(newStepFunction);
      setSelectedPiece(null);
      setCurrentHeight(0);
      
      // Calculate derived values
      const result = calculateAutoconvolutionData(newStepFunction);
      setAutoconvolution(result);
      setTotalHeight(calculateTotalHeight(newStepFunction));
      
      // Set current config to random
      setCurrentConfig('random');
      
      console.log("Successfully generated random step function with", pieces, "pieces");
    } catch (error) {
      console.error("Error generating random step function:", error);
    }
  }, [numPieces, currentConfig, saveCurrentState, calculateAutoconvolutionData]);
  
  // Handle piece selection
  const handlePieceClick = useCallback((index) => {
    if (isDragging) return;
    
    // Find the piece at the given index
    const piece = stepFunction[index];
    
    // Update the height slider to match the selected piece's height
    setCurrentHeight(piece.y);
    
    // Set the selected piece
    setSelectedPiece(index);
  }, [stepFunction, isDragging]);
  
  // Handle piece deselection
  const handlePieceDeselect = useCallback(() => {
    setSelectedPiece(null);
    setCurrentHeight(0);
  }, []);
  
  // Format heights for copying
  const formatHeights = useCallback((heights, format) => {
    switch(format) {
      case 'csv':
        return heights.join(', ');
      case 'python':
        return '[' + heights.join(', ') + ']';
      case 'raw':
        return heights.join('\n');
      default:
        return heights.join(', ');
    }
  }, []);
  
  // Unified function to update height for both slider and direct input
  const updateHeight = useCallback((newHeight) => {
    if (selectedPiece === null) return;
    
    // Ensure the height is valid - it must be a number and non-negative
    const validHeight = typeof newHeight === 'number' && !isNaN(newHeight) 
      ? Math.max(0, newHeight)
      : 0;
    
    // Update current height in state
    setCurrentHeight(validHeight);
    
    // Update step function and calculate autoconvolution immediately
    setStepFunction(prev => {
      // Validate that selectedPiece is still valid
      if (selectedPiece >= prev.length || selectedPiece < 0) return prev;
      
      // Create a new array with the updated piece
      const updated = [...prev];
      updated[selectedPiece] = {
        ...updated[selectedPiece],
        y: validHeight
      };
      
      // Calculate autoconvolution immediately for real-time feedback
      // We need to do this inside the updater function to ensure we're using the updated step function
      const result = calculateAutoconvolutionData(updated);
      setAutoconvolution(result);
      setTotalHeight(calculateTotalHeight(updated));
      
      return updated;
    });
  }, [selectedPiece, calculateAutoconvolutionData]);
  
  // Handle height slider change (keeping for compatibility)
  const handleHeightChange = useCallback((newHeight) => {
    updateHeight(newHeight);
  }, [updateHeight]);
  
  // Handle drag start
  const handleDragStart = useCallback((event, index) => {
    if (index === undefined || index === null) return;
    
    // If clicked on a different piece than currently selected, select it first
    if (selectedPiece !== index) {
      handlePieceClick(index);
      return;
    }
    
    setIsDragging(true);
    
    const chartRect = barChartRef.current.getBoundingClientRect();
    const startY = event.clientY;
    const startHeight = currentHeight;
    
    const handleMouseMove = (moveEvent) => {
      // Calculate delta from start position
      const deltaY = startY - moveEvent.clientY;
      
      // Implement an adaptive scale based on:
      // 1. The current number of pieces (smaller pieces need finer control)
      // 2. The current height (smaller heights need finer adjustments)
      // 3. Whether shift key is pressed (for super fine adjustments)
      
      // Base scale adjusted by number of pieces - more pieces means finer control
      const pieceAdjustment = Math.max(0.4, Math.min(1.0, 50 / numPieces));
      
      // Height adjustment factor - smaller heights get finer control
      const heightAdjustment = Math.max(0.3, Math.min(1.0, startHeight / 5));
      
      // Check if shift key is pressed for fine adjustment mode
      const isShiftPressed = moveEvent.shiftKey;
      const shiftModifier = isShiftPressed ? 0.2 : 1.0;
      
      // Calculate the final scale factor
      const heightScale = (MAX_HEIGHT / (chartRect.height * 0.8)) * 
                           pieceAdjustment * 
                           heightAdjustment * 
                           shiftModifier;
      
      // Apply the scale to get the new height
      const newHeight = Math.max(0, startHeight + deltaY * heightScale);
      
      // Use the unified update height function
      updateHeight(newHeight);
    };
    
    const handleMouseUp = () => {
      setIsDragging(false);
      
      // Remove event listeners
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    // Add event listeners
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [selectedPiece, currentHeight, numPieces, handlePieceClick, updateHeight]);
  
  // Reset zoom (defined first to avoid circular dependency)
  const resetZoom = useCallback(() => {
    setZoomDomain({ xMin: MIN_X, xMax: MAX_X });
    setIsZoomed(false);
    setZoomLevel(1);
  }, []);
  
  // Handle zooming in
  const zoomIn = useCallback(() => {
    // Calculate new zoom domain
    const currentWidth = zoomDomain.xMax - zoomDomain.xMin;
    const newWidth = currentWidth * 0.7; // Zoom in by reducing width
    
    // If a piece is selected, zoom to that piece
    let center;
    if (selectedPiece !== null && stepFunction[selectedPiece]) {
      center = stepFunction[selectedPiece].x;
    } else {
      center = (zoomDomain.xMin + zoomDomain.xMax) / 2;
    }
    
    const newMin = Math.max(MIN_X, center - (newWidth / 2));
    const newMax = Math.min(MAX_X, center + (newWidth / 2));
    
    setZoomDomain({ xMin: newMin, xMax: newMax });
    setZoomLevel(prev => prev + 1);
    setIsZoomed(true);
  }, [zoomDomain, selectedPiece, stepFunction]);
  
  // Handle zooming out
  const zoomOut = useCallback(() => {
    // If we're at zoom level 1 or we're close to full view, just reset zoom completely
    if (zoomLevel <= 1 || (zoomDomain.xMin <= MIN_X + 0.01 && zoomDomain.xMax >= MAX_X - 0.01)) {
      resetZoom();
      return;
    }
    
    // Calculate new zoom domain
    const currentWidth = zoomDomain.xMax - zoomDomain.xMin;
    const newWidth = Math.min(MAX_X - MIN_X, currentWidth * 1.5); // Zoom out by increasing width by 50%
    
    // Use the current center point
    const center = (zoomDomain.xMin + zoomDomain.xMax) / 2;
    
    // Calculate new boundaries
    let newMin = Math.max(MIN_X, center - (newWidth / 2));
    let newMax = Math.min(MAX_X, center + (newWidth / 2));
    
    // If the new width would exceed the full width, just reset zoom
    if (newWidth >= (MAX_X - MIN_X) * 0.95) {
      resetZoom();
      return;
    }
    
    // Make sure we maintain the aspect ratio if we hit a boundary
    if (newMin === MIN_X) {
      newMax = newMin + newWidth;
    } else if (newMax === MAX_X) {
      newMin = newMax - newWidth;
    }
    
    // Update the zoom domain and level
    setZoomDomain({ xMin: newMin, xMax: newMax });
    setZoomLevel(prev => Math.max(1, prev - 1));
    setIsZoomed(true);
  }, [zoomDomain, zoomLevel, resetZoom]);
  
  // Pan left
  const panLeft = useCallback(() => {
    if (!isZoomed) return;
    
    const currentWidth = zoomDomain.xMax - zoomDomain.xMin;
    const panAmount = currentWidth * 0.2; // Pan by 20% of visible width
    const newMin = Math.max(MIN_X, zoomDomain.xMin - panAmount);
    const newMax = newMin + currentWidth;
    
    // Free scrolling mode or no selected piece - pan freely
    if (freeScrolling || selectedPiece === null || !stepFunction[selectedPiece]) {
      setZoomDomain({ xMin: newMin, xMax: newMax });
      return;
    }
    
    // Check if the selected piece would still be in view
    const selectedX = stepFunction[selectedPiece].x;
    // If panning would move the selected piece out of view, don't pan beyond the selected piece
    if (selectedX >= newMin && selectedX <= newMax) {
      setZoomDomain({ xMin: newMin, xMax: newMax });
    } else {
      // Keep selected piece at the right edge of the view
      setZoomDomain({ 
        xMin: Math.max(MIN_X, selectedX - currentWidth * 0.8), 
        xMax: Math.min(MAX_X, selectedX + currentWidth * 0.2) 
      });
    }
  }, [zoomDomain, isZoomed, selectedPiece, stepFunction, freeScrolling]);
  
  // Pan right
  const panRight = useCallback(() => {
    if (!isZoomed) return;
    
    const currentWidth = zoomDomain.xMax - zoomDomain.xMin;
    const panAmount = currentWidth * 0.2; // Pan by 20% of visible width
    const newMax = Math.min(MAX_X, zoomDomain.xMax + panAmount);
    const newMin = newMax - currentWidth;
    
    // Free scrolling mode or no selected piece - pan freely
    if (freeScrolling || selectedPiece === null || !stepFunction[selectedPiece]) {
      setZoomDomain({ xMin: newMin, xMax: newMax });
      return;
    }
    
    // Check if the selected piece would still be in view
    const selectedX = stepFunction[selectedPiece].x;
    // If panning would move the selected piece out of view, don't pan beyond the selected piece
    if (selectedX >= newMin && selectedX <= newMax) {
      setZoomDomain({ xMin: newMin, xMax: newMax });
    } else {
      // Keep selected piece at the left edge of the view
      setZoomDomain({ 
        xMin: Math.max(MIN_X, selectedX - currentWidth * 0.2), 
        xMax: Math.min(MAX_X, selectedX + currentWidth * 0.8) 
      });
    }
  }, [zoomDomain, isZoomed, selectedPiece, stepFunction, freeScrolling]);
  
  // Reset current configuration
  const resetCurrentConfig = useCallback(() => {
    if (currentConfig === 'random') {
      generateRandomStepFunction();
    } else if (currentConfig === 'google') {
      loadPredefinedSolution('google');
    } else if (currentConfig === 'matolcsi') {
      loadPredefinedSolution('matolcsi');
    } else if (currentConfig === 'smooth') {
      loadPredefinedSolution('smooth');
    }
    
    // Also reset zoom
    resetZoom();
    
    // Show notification
    setNotification({
      show: true,
      message: `Reset to ${currentConfig} configuration`,
      type: 'success'
    });
    
    // Auto-hide notification
    setTimeout(() => {
      setNotification(prev => ({ ...prev, show: false }));
    }, 3000);
  }, [currentConfig, generateRandomStepFunction, loadPredefinedSolution, resetZoom]);
  
  // Custom bar chart component with zoom
  const CustomBarChart = () => {
    return (
      <div ref={barChartRef} className="w-full h-64 relative">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart 
            data={stepFunction} 
            barCategoryGap={0} 
            barGap={0}
            onClick={(data) => {
              if (data && data.activeTooltipIndex !== undefined) {
                handlePieceClick(data.activeTooltipIndex);
              }
            }}
            isAnimationActive={false}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis
              dataKey="x"
              type="number"
              domain={[zoomDomain.xMin, zoomDomain.xMax]}
              allowDataOverflow={true}
              tickCount={11}
              tickFormatter={(value) => value.toFixed(3)}
              label={{ value: 'x', position: 'insideBottom', offset: -5 }}
            />
            <YAxis
              domain={[0, 'auto']}
              label={{ value: 'f(x)', angle: -90, position: 'insideLeft' }}
            />
            <Tooltip
              formatter={(value) => [value.toFixed(2), 'f(x)']}
              labelFormatter={(label) => `x: ${Number(label).toFixed(3)}`}
              isAnimationActive={false}
              content={({ active, payload, label }) => {
                if (active && payload && payload.length) {
                  return (
                    <div className="custom-tooltip bg-white p-2 border border-gray-300 rounded shadow-sm">
                      <p className="label mb-1">{`x: ${Number(label).toFixed(3)}`}</p>
                      <p className="value">{`f(x): ${payload[0].value.toFixed(2)}`}</p>
                    </div>
                  );
                }
                return null;
              }}
            />
            <ReferenceLine y={0} stroke="#000" />
            <ReferenceLine x={0} stroke="#000" />
            <Bar 
              dataKey="y" 
              isAnimationActive={false}
              shape={(props) => {
                const { x, y, width, height, index, background } = props;
                const chartHeight = background?.height || 0;
                
                return (
                  <g>
                    {/* Invisible full-height clickable area */}
                    <rect
                      x={x}
                      y={0}
                      width={width}
                      height={chartHeight}
                      fill="transparent"
                      cursor={selectedPiece === index ? 'ns-resize' : 'pointer'}
                      onClick={(e) => {
                        e.stopPropagation();
                        handlePieceClick(index);
                      }}
                      onMouseDown={(e) => {
                        e.stopPropagation();
                        handleDragStart(e, index);
                      }}
                    />
                    
                    {/* Visible bar */}
                    <rect
                      x={x}
                      y={y}
                      width={width}
                      height={height}
                      data-index={index}
                      fill={selectedPiece === index ? "#ff7300" : "#8884d8"}
                      cursor={selectedPiece === index ? 'ns-resize' : 'pointer'}
                      pointerEvents="none" // Let the invisible rectangle handle events
                    />
                    
                    {/* No shift key text indicator */}
                  </g>
                );
              }}
            />
          </BarChart>
        </ResponsiveContainer>
        
        {/* Zoom controls overlay */}
        <div className="absolute top-2 right-2 flex items-center space-x-2 bg-white rounded shadow p-1 border border-gray-200">
          <button
            onClick={zoomIn}
            disabled={zoomLevel >= 10}
            className={`p-1 rounded ${zoomLevel >= 10 ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
            title="Zoom in"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
          </button>
          
          <button
            onClick={zoomOut}
            disabled={!isZoomed}
            className={`p-1 rounded ${!isZoomed ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
            title="Zoom out"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
            </svg>
          </button>
          
          <button
            onClick={panLeft}
            disabled={!isZoomed}
            className={`p-1 rounded ${!isZoomed ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
            title="Pan left"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          </button>
              
          <button
            onClick={panRight}
            disabled={!isZoomed}
            className={`p-1 rounded ${!isZoomed ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
            title="Pan right"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>
              
          <button
            onClick={resetZoom}
            disabled={!isZoomed}
            className={`p-1 rounded ${!isZoomed ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
            title="Reset zoom"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5" />
            </svg>
          </button>
        </div>
      </div>
    );
  };
  
  // Custom line chart for autoconvolution
  const CustomLineChart = () => {
    return (
      <div className="w-full h-64">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart 
            data={autoconvolution}
            isAnimationActive={false}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis
              dataKey="x"
              type="number"
              domain={[-0.5, 0.5]}
              tickCount={11}
              tickFormatter={(value) => value.toFixed(2)}
              label={{ value: 't', position: 'insideBottom', offset: -5 }}
            />
            <YAxis
              domain={[0, 'auto']}
              label={{ value: '(f*f)(t)/(f)', angle: -90, position: 'insideLeft' }}
            />
            <Tooltip
              formatter={(value) => [value.toFixed(3), '(f*f)(t)/(f)']}
              labelFormatter={(label) => `t: ${Number(label).toFixed(3)}`}
              isAnimationActive={false}
            />
            <ReferenceLine y={0} stroke="#000" />
            <ReferenceLine x={0} stroke="#000" />
            <ReferenceLine y={GOOGLE_BOUND} stroke="#FF0000" strokeDasharray="5 5" />
            <Line
              type="monotone"
              dataKey="y"
              stroke="#82ca9d"
              dot={false}
              isAnimationActive={false}
            />
          </LineChart>
        </ResponsiveContainer>
      </div>
    );
  };
  
  // Add the initialization effect now that all functions are defined
  useEffect(() => {
    if (!isInitialized) {
      setIsInitialized(true);
      generateRandomStepFunction();
    }
  }, [isInitialized, generateRandomStepFunction]);
  
  // Effect to update ONLY when lastManualPiecesChange changes (slider is moved)
  useEffect(() => {
    // Skip the initial render (only respond to actual slider changes)
    if (lastManualPiecesChange === 0) return;
    
    // Skip if not in random mode
    if (currentConfig !== 'random') return;
    
    console.log("Slider change detected, timestamp:", lastManualPiecesChange);
    
    // Use a ref to track if this effect has already run for this timestamp
    // This prevents potential re-renders from causing multiple updates
    const timestamp = lastManualPiecesChange;
    
    const timerId = setTimeout(() => {
      // Create a new array of random heights
      const pieces = numPieces;
      let heights = new Array(pieces);
      
      // Fill with random heights between 0.1 and 5
      for (let i = 0; i < pieces; i++) {
        heights[i] = 0.1 + Math.random() * 4.9;
      }
      
      // Add some higher values for visual interest
      const numHighValues = Math.min(10, Math.floor(pieces * 0.1));
      for (let i = 0; i < numHighValues; i++) {
        const randomIndex = Math.floor(Math.random() * pieces);
        heights[randomIndex] = 5 + Math.random() * 5; // Values between 5-10
      }
      
      // Create a new step function with these heights
      const newStepFunction = createStepFunction(heights);
      
      // Batch all state updates together to minimize re-renders
      // This is critical to prevent cascading updates
      setStepFunction(newStepFunction);
      setSelectedPiece(null);
      setCurrentHeight(0);
      
      // Calculate derived values
      const result = calculateAutoconvolutionData(newStepFunction);
      setAutoconvolution(result);
      setTotalHeight(calculateTotalHeight(newStepFunction));
      
      console.log("Updated step function for new pieces count:", pieces);
    }, 50);
    
    return () => clearTimeout(timerId);
    
    // CRITICAL: Only depend on lastManualPiecesChange, not on any values that change as a result
    // of updating the step function. This breaks the loop.
  }, [lastManualPiecesChange]);

  // Notification Component
  const Notification = () => {
    if (!notification.show) return null;
    
    const bgColor = notification.type === 'success' ? 'bg-green-100 border-green-500' : 'bg-red-100 border-red-500';
    const textColor = notification.type === 'success' ? 'text-green-700' : 'text-red-700';
    
    return (
      <div className={`fixed top-4 right-4 px-4 py-3 rounded border ${bgColor} ${textColor} z-50 shadow-md`}>
        <span className="font-medium">{notification.message}</span>
        <button 
          onClick={() => setNotification(prev => ({ ...prev, show: false }))}
          className="ml-3 font-bold"
        >
          
        </button>
      </div>
    );
  };

  return (
    <div className="flex flex-col p-4 space-y-4 max-w-5xl mx-auto">
      <Notification />
      <div className="text-2xl font-bold text-center">Step Function Autoconvolution</div>
      
      {/* Controls */}
      <div className="bg-white p-4 rounded-lg shadow">
        <div className="grid grid-cols-2 gap-6">
          {/* Left column - Sliders */}
          <div className="flex flex-col space-y-6">
            {/* Tip banner for dragging with shift key */}
            <div className="bg-blue-50 border-l-4 border-blue-400 p-2 rounded shadow-sm mb-2">
              <div className="flex items-center text-sm text-blue-700">
                <span className="mr-1"></span>
                <span>
                  <strong>Tip:</strong> Hold <kbd className="bg-gray-200 px-1 rounded">Shift</kbd> key when dragging bars on the chart for fine adjustments
                </span>
              </div>
            </div>
            
            <div>
              <div className="mb-2 font-medium flex justify-between">
                <span>Number of Pieces: {numPieces}</span>
                {currentConfig !== 'random' && (
                  <span className="text-xs text-gray-500 italic">
                    (Fixed for {currentConfig === 'google' ? 'Google' : currentConfig === 'matolcsi' ? 'MV' : 'Smooth'} solution)
                  </span>
                )}
              </div>
              <div className="relative w-full">
                <input
                  type="range"
                  min="5"
                  max={MAX_PIECES}
                  value={numPieces}
                  disabled={currentConfig !== 'random'}
                  onChange={(e) => {
                    // Only process changes if in random mode
                    if (currentConfig !== 'random') return;
                    
                    try {
                      // Get the new value, ensure it's a valid number
                      const newValue = Math.max(5, Math.floor(Number(e.target.value)));
                      
                      if (isNaN(newValue) || newValue <= 0) {
                        console.error("Invalid slider value:", e.target.value);
                        return;
                      }
                      
                      console.log("Setting numPieces from slider:", newValue);
                      
                      // Update the number of pieces
                      setNumPieces(newValue);
                      
                      // Track that this was a manual change - use a timestamp
                      setLastManualPiecesChange(Date.now());
                    } catch (error) {
                      console.error("Error updating pieces:", error);
                    }
                  }}
                  className={`w-full ${currentConfig === 'random' ? 'slider-thumb-orange' : 'opacity-60 cursor-not-allowed'}`}
                  style={{
                    background: `linear-gradient(to right, #8884d8 0%, #8884d8 ${(numPieces / MAX_PIECES) * 100}%, #e5e7eb ${(numPieces / MAX_PIECES) * 100}%, #e5e7eb 100%)`
                  }}
                />
              </div>
            </div>
            
            <div>
              <div className="mb-2 font-medium flex justify-between items-center">
                <span>Height Adjustment:</span>
                <div className="flex items-center space-x-2">
                  <button 
                    onClick={() => {
                      if (selectedPiece === null) return;
                      const newHeight = Math.max(0, currentHeight - 0.01);
                      updateHeight(newHeight);
                    }}
                    onMouseDown={() => {
                      if (selectedPiece === null) return;
                      
                      // Reference to store interval ID
                      const timers = {
                        interval: null,
                        timeout: null
                      };
                      
                      // Function to decrease height - gets called repeatedly
                      const decreaseHeight = () => {
                        setCurrentHeight(prevHeight => {
                          const newHeight = Math.max(0, prevHeight - 0.01);
                          updateHeight(newHeight);
                          return newHeight;
                        });
                      };
                      
                      // Create cleanup function
                      const cleanup = () => {
                        if (timers.timeout) clearTimeout(timers.timeout);
                        if (timers.interval) clearInterval(timers.interval);
                        document.removeEventListener('mouseup', cleanup);
                      };
                      
                      // Start timer after short delay
                      timers.timeout = setTimeout(() => {
                        timers.interval = setInterval(decreaseHeight, 50);
                      }, 300);
                      
                      // Add global mouseup listener to stop when mouse is released anywhere
                      document.addEventListener('mouseup', cleanup);
                    }}
                    disabled={selectedPiece === null}
                    className={`p-1 rounded ${selectedPiece === null ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
                    title="Decrease by 0.01 (hold for continuous)"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
                    </svg>
                  </button>
                  
                  <input
                    type="number"
                    min="0"
                    max={MAX_HEIGHT * 5}
                    step="0.01"
                    value={currentHeight}
                    disabled={selectedPiece === null}
                    onChange={(e) => {
                      if (selectedPiece === null) return;
                      const newHeight = Number(e.target.value);
                      if (!isNaN(newHeight) && newHeight >= 0) {
                        updateHeight(newHeight);
                      }
                    }}
                    className="w-20 p-1 text-sm text-center border rounded"
                  />
                  
                  <button 
                    onClick={() => {
                      if (selectedPiece === null) return;
                      const newHeight = currentHeight + 0.01;
                      updateHeight(newHeight);
                    }}
                    onMouseDown={() => {
                      if (selectedPiece === null) return;
                      
                      // Reference to store interval ID
                      const timers = {
                        interval: null,
                        timeout: null
                      };
                      
                      // Function to increase height - gets called repeatedly
                      const increaseHeight = () => {
                        setCurrentHeight(prevHeight => {
                          const newHeight = prevHeight + 0.01;
                          updateHeight(newHeight);
                          return newHeight;
                        });
                      };
                      
                      // Create cleanup function
                      const cleanup = () => {
                        if (timers.timeout) clearTimeout(timers.timeout);
                        if (timers.interval) clearInterval(timers.interval);
                        document.removeEventListener('mouseup', cleanup);
                      };
                      
                      // Start timer after short delay
                      timers.timeout = setTimeout(() => {
                        timers.interval = setInterval(increaseHeight, 50);
                      }, 300);
                      
                      // Add global mouseup listener to stop when mouse is released anywhere
                      document.addEventListener('mouseup', cleanup);
                    }}
                    disabled={selectedPiece === null}
                    className={`p-1 rounded ${selectedPiece === null ? 'text-gray-400' : 'text-blue-500 hover:bg-blue-100'}`}
                    title="Increase by 0.01 (hold for continuous)"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                  </button>
                </div>
              </div>
              
              <div className="flex space-x-2 mb-2">
                <div className="relative w-full">
                  <input
                    type="range"
                    min="0"
                    max={MAX_HEIGHT * 5}
                    step="0.01"
                    value={currentHeight}
                    disabled={selectedPiece === null}
                    className="w-full slider-thumb-orange"
                    onInput={(e) => {
                      if (selectedPiece === null) return;
                      const newHeight = Number(e.target.value);
                      updateHeight(newHeight);
                    }}
                    style={{
                      background: selectedPiece !== null ? 
                        `linear-gradient(to right, #ff7300 0%, #ff7300 ${(currentHeight / (MAX_HEIGHT * 5)) * 100}%, #e5e7eb ${(currentHeight / (MAX_HEIGHT * 5)) * 100}%, #e5e7eb 100%)` : 
                        '#e5e7eb'
                    }}
                  />
                </div>
              </div>
              
              <div className="flex justify-between text-xs text-gray-500">
                <button 
                  onClick={() => updateHeight(0.1)}
                  disabled={selectedPiece === null}
                  className={`${selectedPiece === null ? 'text-gray-400' : 'text-blue-500 hover:underline'}`}
                >0.1</button>
                <button 
                  onClick={() => updateHeight(1)}
                  disabled={selectedPiece === null}
                  className={`${selectedPiece === null ? 'text-gray-400' : 'text-blue-500 hover:underline'}`}
                >1.0</button>
                <button 
                  onClick={() => updateHeight(5)}
                  disabled={selectedPiece === null}
                  className={`${selectedPiece === null ? 'text-gray-400' : 'text-blue-500 hover:underline'}`}
                >5.0</button>
                <button 
                  onClick={() => updateHeight(10)}
                  disabled={selectedPiece === null}
                  className={`${selectedPiece === null ? 'text-gray-400' : 'text-blue-500 hover:underline'}`}
                >10.0</button>
              </div>
            </div>
          </div>
          
          {/* Right column - Buttons and Info */}
          <div className="flex flex-col justify-between">
            <div className="flex flex-col space-y-2">
              <div className="font-medium mb-2">Selected Piece: {selectedPiece !== null ? selectedPiece : 'None'}</div>
              <div className="flex flex-col space-y-2">
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-2">
                  <button
                    onClick={generateRandomStepFunction}
                    className="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600"
                  >
                    Random
                  </button>
                  
                  <button
                    onClick={() => loadPredefinedSolution('google')}
                    className="bg-green-600 text-white px-3 py-2 rounded hover:bg-green-700"
                  >
                    Google (600)
                  </button>
                  
                  <button
                    onClick={() => loadPredefinedSolution('matolcsi')}
                    className="bg-purple-600 text-white px-3 py-2 rounded hover:bg-purple-700"
                  >
                    MV (208)
                  </button>
                  
                  <button
                    onClick={() => loadPredefinedSolution('smooth')}
                    className="bg-orange-600 text-white px-3 py-2 rounded hover:bg-orange-700"
                  >
                    Smooth (600)
                  </button>
                  
                  <button
                    onClick={resetCurrentConfig}
                    className="bg-gray-600 text-white px-3 py-2 rounded hover:bg-gray-700"
                    title={`Reset the current ${currentConfig} configuration`}
                  >
                    Reset
                  </button>
                </div>
                
                <div className="flex space-x-2">
                  <div className="flex flex-col space-y-2 flex-1">
                    <div className="flex space-x-2">
                      <select
                        value={copyFormat}
                        onChange={(e) => setCopyFormat(e.target.value)}
                        className="bg-white border border-gray-300 rounded px-2 py-1 text-sm flex-1"
                      >
                        <option value="csv">CSV Format</option>
                        <option value="python">Python Array</option>
                        <option value="raw">Raw (One per line)</option>
                      </select>
                      
                      <button
                        onClick={() => {
                          const heights = stepFunction.map(step => step.y);
                          const formattedHeights = formatHeights(heights, copyFormat);
                          
                          navigator.clipboard.writeText(formattedHeights)
                            .then(() => {
                              setNotification({ 
                                show: true, 
                                message: 'Heights copied to clipboard!', 
                                type: 'success' 
                              });
                              
                              // Auto-hide notification after 3 seconds
                              setTimeout(() => {
                                setNotification(prev => ({ ...prev, show: false }));
                              }, 3000);
                            })
                            .catch(err => {
                              console.error('Failed to copy: ', err);
                              setNotification({ 
                                show: true, 
                                message: 'Failed to copy heights', 
                                type: 'error' 
                              });
                              
                              // Auto-hide notification after 3 seconds
                              setTimeout(() => {
                                setNotification(prev => ({ ...prev, show: false }));
                              }, 3000);
                            });
                        }}
                        className="bg-yellow-500 text-white px-3 py-1 rounded hover:bg-yellow-600"
                      >
                        Copy
                      </button>
                    </div>
                    
                    <div className="flex items-center justify-between">
                      <div className="text-sm">
                        <span className="font-medium">Max Value:</span> 
                        <span className="text-green-700 ml-1">{maxAutoconvValue.toFixed(6)}</span>
                        <button
                          onClick={() => {
                            navigator.clipboard.writeText(maxAutoconvValue.toFixed(6))
                              .then(() => {
                                setNotification({ 
                                  show: true, 
                                  message: 'Max value copied!', 
                                  type: 'success' 
                                });
                                setTimeout(() => setNotification(prev => ({ ...prev, show: false })), 3000);
                              });
                          }}
                          className="ml-2 text-blue-500 hover:text-blue-700 text-xs underline"
                        >
                          Copy
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <div className="text-sm text-gray-700 mt-4">
              <div className="font-semibold">Instructions:</div>
              <ol className="list-decimal pl-5 mt-1">
                <li>Click on any bar to select it (turns orange)</li>
                <li>Drag selected bar up/down to adjust height or use the slider</li>
                <li><strong>Hold Shift key</strong> while dragging for fine-grained adjustments</li>
                <li>Use the zoom controls (+ and -) to zoom in/out on the x-axis</li>
                <li>When zoomed in, use the left/right arrows to pan the view</li>
                <li>Click the expand icon to reset zoom back to full view</li>
                <li>Use "Copy" with format selector to copy all step heights to clipboard</li>
                <li>The "Reset" button restores the current configuration to its original state</li>
                <li>The autoconvolution plot shows Google's bound at 1.5053</li>
              </ol>
            </div>
          </div>
        </div>
      </div>
      
      {/* Step Function Chart */}
      <div className="bg-white p-4 rounded-lg shadow">
        <div className="flex justify-between items-center mb-2">
          <div className="font-semibold">LP Step Function (P={numPieces})</div>
          {isZoomed && (
            <div className="text-xs text-blue-600">
              Zoomed: [{zoomDomain.xMin.toFixed(3)}, {zoomDomain.xMax.toFixed(3)}]
            </div>
          )}
        </div>
        <CustomBarChart />
      </div>
      
      {/* Autoconvolution Chart */}
      <div className="bg-white p-4 rounded-lg shadow">
        <div className="flex justify-between items-center mb-2">
          <div className="font-semibold">LP Autoconvolution (f*f)(t)/(f) (P={numPieces})</div>
          <div className="text-green-700">Max Value: {maxAutoconvValue.toFixed(6)}</div>
        </div>
        <CustomLineChart />
        <div className="text-sm mt-2 text-red-600">Google's bound: {GOOGLE_BOUND} (red line)</div>
      </div>
      
    </div>
  );
};

export default StepFunctionVisualizer;